Classification

Heartbeat types: ["N","L","R","A","a","J","S","V","F","e","j","E"]
Trained with samples generated by DCGAN

Model: 34 layer Residential Energy Services Network

#----------------------------------------------------------------------------------------------#

class BasicBlock(nn.Module):
	def __init__(self,in_channels,out_channels,kernel_size,stride,padding):
		super(BasicBlock,self).__init__()

		self.conv1=nn.Sequential(
			nn.Conv1d(in_channels,out_channels,kernel_size,stride,padding),
			nn.BatchNorm1d(out_channels),
			nn.ReLU(True),
		)

		self.conv2=nn.Sequential(
			nn.Conv1d(out_channels,out_channels,3,1,1),
			nn.BatchNorm1d(out_channels)
		)

		self.relu=nn.ReLU(True)

		if in_channels!=out_channels or (kernel_size,stride,padding)!=(3,1,1):
			self.shortcut=nn.Sequential(
				nn.Conv1d(in_channels,out_channels,kernel_size,stride,padding,bias=False),
				nn.BatchNorm1d(out_channels),
			)
		else:
			self.shortcut=nn.Sequential()

	def forward(self,x):
		out=self.conv1(x)
		out=self.conv2(out)
		out+=self.shortcut(x)
		out=self.relu(out)
		return out

class ResNetLayer(nn.Module):
	def __init__(self,num_blocks,in_channels,out_channels,kernel_size,stride,padding):
		super(ResNetLayer,self).__init__()
		blocks=[]
		blocks.append(BasicBlock(in_channels,out_channels,kernel_size,stride,padding))
		for i in range(num_blocks-1):
			blocks.append(BasicBlock(out_channels,out_channels,3,1,1))
		self.main=nn.Sequential(*blocks)

	def forward(self,x):
		return self.main(x)

class ResNet34(nn.Module):
	def __init__(self,num_types):
		super(ResNet34,self).__init__()
		self.main=nn.Sequential(
			nn.Conv1d(1,64,3,1,1,bias=False),
			nn.BatchNorm1d(64),
			ResNetLayer(3,64,64,4,2,1),
			ResNetLayer(4,64,128,8,4,2),
			ResNetLayer(6,128,256,8,4,2),
			ResNetLayer(3,256,512,6,1,0),
			nn.AdaptiveAvgPool1d(1),
			nn.Flatten(),
			nn.Linear(512,num_types),
			nn.Softmax(dim=1),
		)

	def forward(self,x):
		x=x.view(-1,1,216)
		return self.main(x)

#----------------------------------------------------------------------------------------------#

Optimizer: SGD
Learning rate: 0.0002

Loss: CrossEntropyLoss

Batch size: 240
Training steps (steps of one batch): 3000

Testset accuracy=0.7331897679=36430/49687
Confusion matrix:
36430 0 0 0 0 0 0 0 0 0 0 0
4124 0 0 0 0 0 0 0 0 0 0 0
3475 0 0 0 0 0 0 0 0 0 0 0
1736 0 0 0 0 0 0 0 0 0 0 0
50 0 0 0 0 0 0 0 0 0 0 0
51 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
3219 0 0 0 0 0 0 0 0 0 0 0
388 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
213 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0
